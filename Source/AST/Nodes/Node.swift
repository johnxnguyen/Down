//
//  Node.swift
//  Down
//
//  Created by John Nguyen on 07.04.19.
//

import Foundation
import libcmark

public typealias CMarkNode = UnsafeMutablePointer<cmark_node>

/// A node is a wrapper of a raw `CMarkNode` belonging to the abstract syntax tree
/// generated by cmark.
///
public protocol Node {
    /// The wrapped node.
    var cmarkNode: CMarkNode { get }
    
    /// The wrapped child nodes.
    var childen: [Node] { get }
}

extension Node {
    /// True iff the node has a sibling that succeeds it.
    public var hasSuccessor: Bool {
        return cmark_node_next(cmarkNode) != nil
    }
    
    /// The children of this node.
    public var childen: [Node] {
        var result: [Node] = []
        var child = cmark_node_first_child(cmarkNode)
        
        while let raw = child {
            let wrapped: Node?
            let type = raw.type
            
            switch type {
            case CMARK_NODE_DOCUMENT:       wrapped = Document(cmarkNode: raw)
            case CMARK_NODE_BLOCK_QUOTE:    wrapped = BlockQuote(cmarkNode: raw)
            case CMARK_NODE_LIST:           wrapped = List(cmarkNode: raw)
            case CMARK_NODE_ITEM:           wrapped = Item(cmarkNode: raw)
            case CMARK_NODE_CODE_BLOCK:     wrapped = CodeBlock(cmarkNode: raw)
            case CMARK_NODE_HTML_BLOCK:     wrapped = HtmlBlock(cmarkNode: raw)
            case CMARK_NODE_CUSTOM_BLOCK:   wrapped = CustomBlock(cmarkNode: raw)
            case CMARK_NODE_PARAGRAPH:      wrapped = Paragraph(cmarkNode: raw)
            case CMARK_NODE_HEADING:        wrapped = Heading(cmarkNode: raw)
            case CMARK_NODE_THEMATIC_BREAK: wrapped = ThematicBreak(cmarkNode: raw)
            case CMARK_NODE_TEXT:           wrapped = Text(cmarkNode: raw)
            case CMARK_NODE_SOFTBREAK:      wrapped = SoftBreak(cmarkNode: raw)
            case CMARK_NODE_LINEBREAK:      wrapped = LineBreak(cmarkNode: raw)
            case CMARK_NODE_CODE:           wrapped = Code(cmarkNode: raw)
            case CMARK_NODE_HTML_INLINE:    wrapped = HtmlInline(cmarkNode: raw)
            case CMARK_NODE_CUSTOM_INLINE:  wrapped = CustomInline(cmarkNode: raw)
            case CMARK_NODE_EMPH:           wrapped = Emphasis(cmarkNode: raw)
            case CMARK_NODE_STRONG:         wrapped = Strong(cmarkNode: raw)
            case CMARK_NODE_LINK:           wrapped = Link(cmarkNode: raw)
            case CMARK_NODE_IMAGE:          wrapped = Image(cmarkNode: raw)
            default:                        fatalError("Unexpected node type: \(type)")
            }
            
            guard let node = wrapped else {
                fatalError("Couldn't wrap node of type: \(type)")
            }
            
            result.append(node)
            child = cmark_node_next(child)
        }
        
        return result
    }
}

// MARK: - Helper extensions

extension UnsafeMutablePointer where Pointee == cmark_node {
    
    var type: cmark_node_type {
        return cmark_node_get_type(self)
    }
    
    var literal: String? {
        return String(cString: cmark_node_get_literal(self))
    }
    
    var fenceInfo: String? {
        return String(cString: cmark_node_get_fence_info(self))
    }
    
    var headingLevel: Int {
        return Int(cmark_node_get_heading_level(self))
    }
    
    var listType: cmark_list_type {
        return cmark_node_get_list_type(self)
    }
    
    var listStart: Int {
        return Int(cmark_node_get_list_start(self))
    }
    
    var url: String? {
        return String(cString: cmark_node_get_url(self))
    }
    
    var title: String? {
        return String(cString: cmark_node_get_title(self))
    }
}

private extension String {
    
    init?(cString: UnsafePointer<Int8>?) {
        guard let unwrapped = cString else { return nil }
        let result = String(cString: unwrapped)
        guard !result.isEmpty else { return nil }
        self = result
        
    }
}
